<!DOCTYPE html>
<meta charset="utf-8">
<title>SANKEY Experiment</title>
<style>
.node rect {
/*  cursor: move;*/
  fill-opacity: .95;
  shape-rendering: crispEdges;
}
.highlight {
  fill: #444;
}

.node text {
  font-family: sans-serif;
  font-size: 12px;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link {
  fill: none;
  stroke: #000;
  stroke-opacity: .65;
  transition: stroke-opacity 600ms ease;
}
/*.link-highlight {
  stroke-opacity: .2;
}*/
.mask {
  stroke-opacity: .05;
  
}

/*.link:hover {
  stroke-opacity: .5;
}*/
</style>

<body>
  
<div id="chart-container" style="max-width: 600px; min-width: 320px">
  <h1> Bozeman's proposed budget   </h1>
  <p> For fiscal year 2017, running July 2016 to June 2017. Hover or tap to highlight individual portions.
  <div id="chart" style="width:100%;" ></div>
  <div id="dynamic-info" style="width:100%;">
    <p>This is filler!</p>
  </div>
</div>
  
  
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="sankey-modified.js"></script>
  <script>

    var MOBILE_BREAK = 400; // breakpoint for responsiveness

      // UTILITY FUNCTIONS


    // });

    d3.json("combined.json", function(error, graph) {
      var chart = new SankeyChart({
        element: document.querySelector('#chart'),
        data: graph 
      });
    });

  var SankeyChart = function(opts) {
    this.data = opts.data;
    this.element = opts.element;

    this.draw();

    // redraw on window resize
    var that = this;
    d3.select(window).on('resize', function(){
      that.draw();
    });
  };
  
  SankeyChart.prototype.draw = function(){
    
    this.width = this.element.offsetWidth;
    this.height = this.width;
    this.margin = {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10
      };
    
    this.nodeWidth = 30;
    this.nodePadding = 2;

    // Decide whether to draw in mobile or desktop mode
    this.drawMode = this.checkSize();

    // Adjust for desktop display
    if (this.drawMode === 'desktop'){
      this.height = this.width * (3/4);
      this.margin.right = 100;
      this.margin.left = 100;
      this.nodeWidth = 15;

    }

    this.plotWidth = this.width - this.margin.left - this.margin.right;
    this.plotHeight = this.height - this.margin.top - this.margin.bottom;

    this.formatNumber = d3.format(",.0f"), // zero decimal places
      format = function(d) {
          return '$' + formatNumber(d);
      },
      color = d3.scale.category20();

    // append the svg canvas to the page
    this.element.innerHTML = '';
    this.svg = d3.select(this.element).append("svg")
      .attr("width", this.width)
      .attr("height", this.height)
      
    this.plot = this.svg.append('g')
      .attr("transform",
          "translate(" + this.margin.left + "," + this.margin.top + ")");

    // Set the sankey diagram properties
    this.sankey = d3.sankey()
      .nodeWidth(this.nodeWidth)
      .nodePadding(this.nodePadding)
      .size([this.plotWidth, this.plotHeight]);

    this.path = this.sankey.link();

    this.sankey
      .nodes(this.data.nodes)
      .links(this.data.links)
      .layout(0);


    // Add link elements
    this.link = this.plot.append('g').selectAll(".link")
      .data(this.data.links);

    // Draw links
    this.link.enter().append("path")
      .attr("class", "link")
      .attr("d", this.path)
      .style("stroke-width", function(d) { return Math.max(1, d.dy);})
      .style("stroke", function(d) { return d3.rgb(d.source.color).darker(0); })
      .sort(function(a, b) {
          return b.dy - a.dy;
      });

      // // add the link titles
      // link.append("title")
      //   .text(function(d) {
      //     return d.source.name + " â†’ " +
      //       d.target.name + "\n" + format(d.value);
      //   });

    // Add node elements
    this.node = this.plot.append("g").selectAll(".node")
      .data(this.data.nodes)
      .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      });

    // add the rectangles for the nodes
    this.node.append("rect")
      .attr("height", function(d) {
        return d.dy;
      })
      .attr("width", this.sankey.nodeWidth())
      .attr("class", "node-rect")
      .style("fill", function(d) {
        // return '#888'
        return d.color;
        // return d.color = color(d.name.replace(/ .*/, ""));
      })
      .style("stroke", function(d) {
        // return '#555'
        return d3.rgb(d.color).darker(0.5);
      });

        // node.append("title")
        // .text(function(d) {
        //   return d.name + "\n" + format(d.value);
        // });

    // add in the title for the nodes
    if(this.drawMode === 'desktop') {
      this.node.append("text")
      .filter(function(d) { return d.col === 1 || d.col === 3;})
      .filter(function(d) { return d.value > 500000; })
        .attr("x", -6)
        .attr("y", function(d) { return d.dy / 2; })
        .attr("dy", ".35em")
        .attr("text-anchor", "end")
        .attr("transform", null)
        .text(function(d) { return d['label-name']; })
        // .call(wrap)
      .filter(function(d) { return d.col > 1; })
        .attr("x", 6 + this.sankey.nodeWidth())
        .attr("text-anchor", "start");
    }

    this.addListeners();
    
  };
  SankeyChart.prototype.checkSize = function(){
      return this.width > MOBILE_BREAK ? 'desktop' : 'mobile';
  };
  SankeyChart.prototype.addListeners = function(){
    /*
    Interaction logic: 
    Hover on/off select works by default
    Click on node turns on hold state, selects node
    Click on any node turns off hold state, deselects
    Hover has no effect during hold state
    */

    var highlightElement = null;
    var holdState = false;

    var onHighlight = function(){
      if (holdState === false){
        highlightElement = d3.select(this);
        refreshHighlight();
      }
    };
    var offHighlight = function(){
      if (holdState === false){
        highlightElement = null;
        refreshHighlight();
      }
    };
    var click = function(){
      if (holdState === true) {
        highlightElement = null;
        holdState = false;
        refreshHighlight();
      } 
      else {
        highlightElement = d3.select(this);
        holdState = true;
        refreshHighlight();
      }
    };
    var refreshHighlight = function(){
        // if highlightElement = null, turn everything back
        // else mask everything except highlight node links
        if (highlightElement !== null){
          var sourceLinks = highlightElement.datum().targetLinks;
          var targetLinks = highlightElement.datum().sourceLinks;
          // add links one node removed 
          sourceLinks.forEach(function(d){
            d.source.targetLinks.forEach(function(d){
              sourceLinks.push(d);
            });
          });
          targetLinks.forEach(function(d){
            d.target.sourceLinks.forEach(function(d){
              targetLinks.push(d);
            });
          });

          var highlightLinks = targetLinks.concat(sourceLinks);
          
          d3.selectAll('.link')
            .filter(function(link) {
              // check whether each link object is in highlightLinks
              i = highlightLinks.indexOf(link);
              return i === -1;
            })
            .classed("mask", true);
          // console.log(highlightElement.datum().targetLinks);
        }
        else {
          d3.selectAll('.link')
            .classed("mask", false);
        }
    };

    this.plot.selectAll(".node-rect")
      .on("mouseover", onHighlight)
      .on("mouseout", offHighlight)
      .on("click", click);
  
  };

  // function wrap(text) {
  //     var wrapWidth = 50;
  //     // Adapted from: http://bl.ocks.org/mbostock/7555321
  //     text.each(function(){
  //       console.log(d3.select(this).text());
  //       var text = d3.select(this),
  //         words = text.text().split(/\s+/).reverse(),
  //         word,
  //         line = [],
  //         lineNumber = 0,
  //         lineHeight = 1.1, // ems
  //         x = text.attr("x"),
  //         y = text.attr("y"),
  //         dy = 0,
  //         tspan = text.text(null).append("tspan").attr("y", y).attr("dy", dy + "em");

  //       while (word = words.pop()) {
  //         line.push(word);
  //         tspan.text(line.join(" "));
  //         if (tspan.node().getComputedTextLength() > wrapWidth) {
  //           line.pop();
  //           tspan.text(line.join(" "));
  //           line = [word];
  //           tspan = text.append("tspan")
  //             .attr("x", x)
  //             .attr("y", y)
  //             .attr("dy", ++lineNumber * lineHeight + dy + "em")
  //             .text(word);
  //         }
  //       }
  //       console.log(text.text());
  //     });
  // };
    
  </script>
  
</body>

</html>
